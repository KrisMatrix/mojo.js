
# Introduction to mojo.js

A quick example-driven introduction to the wonders of [mojo.js](https://mojojs.org).

## Two Variants

At its heart mojo.js is an MVC framework, loosely following the architectural pattern. That means it wants you to
cleanly separate the parts of your web application into Models, Views and Controllers. On the file system that is
reflected as separate directories and files for different concerns.

```
`-- blog
    |-- controllers
    |   |-- users.js
    |   `-- posts.js
    |-- models
    |   |-- users.js
    |   `-- posts.js
    |-- public
    |   `-- app.css
    |-- views
    |   |--layouts
    |   |  `-- default.html.ejs
    |   `-- posts
    |       `-- list.html.ejs
    |-- config.json
    `-- index.js
```

What these files actually look like we will cover in detail later on in another guide. For now it is just important for
you to know that this is considered the ideal structure for a mojo.js application. Because for the remainder of this
guide we will be using a second variant.

```
`-- blog.js
```

For tasks like prototyping and documentantion examples, clean abstraction with many different files can be a little
distracting. So mojo.js can also be used for single file applications. And these single file apps can later on smoothly
transition to proper MVC abstraction as they grow. This one of the fundamental mojo.js philosophies.

## Installation

All you need to get started with mojo.js is [Node.js](https://nodejs.org) 15.0.0 (or newer). We do recommend the use of
an [nvm](https://nvm.sh) environment though.

```
$ npm install -g @mojojs/mojo
...
```

You can install mojo.js with `npm` globally, or in a project specific `node_modules` directory.

```
$ mkdir myapp
$ cd myapp
$ npm i @mojojs/mojo
...
```

Be aware that mojo.js uses [ES modules](https://nodejs.org/api/esm.html), so your `package.json` should include a
`"type": "module"`. Or you have to use the `.mjs` file extension instead of `.js`.

```json
{
  "type": "module",
  "dependencies": {
    "@mojojs/mojo": ">=0.0.1-alpha.21"
  }
}
```

## Hello World

A simple Hello World application looks like this. Save it into a file `myapp.js` and you already got a fully functional
web application. The whole framework was specifically designed with `async`/`await` in mind, so almost everything
returns a `Promise`.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

app.get('/', async ctx => {
  await ctx.render({text: 'Hello World!'});
});

app.start();
```

There is also a helper command available to generate a small example application for you.

```
$ npx mojo gen-lite-app
...
```

## Commands

Many different commands are automatically available from the command line.

```
$ node myapp.js server
[39028] Web application available at http://127.0.0.1:3000/

$ node myapp.js server -l http://*:8080
[39029] Web application available at http://127.0.0.1:8080/

$ node myapp.js get /
Hello World!

$ node myapp.js --help
...List of available commands...
```

The `app.start()` call, which is usually the last statement in your application, starts the command system.


## Reloading

During development you don't want to restart your web server after every change, so we recommend the use of
[nodemon](https://www.npmjs.com/package/nodemon).

```
$ npm i nodemon
...

$ npx nodemon myapp.js server
...
[39248] Web application available at http://127.0.0.1:3000/
```

## Routes

Routes are basically just fancy paths that can contain different kinds of placeholders and usually lead to an action, if
they match the path part of the request URL. The first argument passed to all actions (`ctx`) is a context object,
containing both the HTTP request and response.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// Route leading to an action that renders some text
app.get('/foo', async ctx => {
  await ctx.render({text: 'Hello World!'});
});

app.start();
```

Response content is often generated by actions with a `ctx.render()` call, but more about that later.

## GET and POST parameters

All GET and POST parameters sent with the request are accessible via `ctx.params()`, which returns a `Promise` that
resolves with a [URLSearchParams](https://nodejs.org/api/url.html#url_class_urlsearchparams) object.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// GET /foo?user=sri
app.get('/foo', async ctx => {
  const params = await ctx.params();
  const user = params.get('user');
  await ctx.render({text: `Hello ${user}`});
});

app.start();
```
