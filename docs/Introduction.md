
# Introduction to mojo.js

A quick example-driven introduction to the wonders of [mojo.js](https://mojojs.org).

## Two Variants

At its heart mojo.js is an MVC framework, loosely following the
[architectural pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). That means it wants you to
cleanly separate the parts of your web application into Models, Views and Controllers. On the file system that is
reflected as separate directories and files for different concerns.

```
`-- blog
    |-- controllers
    |   |-- users.js
    |   `-- posts.js
    |-- models
    |   |-- users.js
    |   `-- posts.js
    |-- public
    |   `-- app.css
    |-- views
    |   |--layouts
    |   |  `-- default.html.ejs
    |   `-- posts
    |       `-- list.html.ejs
    |-- config.json
    `-- index.js
```

What these files actually look like we will cover in detail later on in another guide. For now it is just important for
you to know that this is considered the ideal structure for a mojo.js application. Because for the remainder of this
guide we will be using a second variant.

```
`-- blog.js
```

For tasks like prototyping and documentantion examples, clean abstraction with many different files can be a little
distracting. So mojo.js can also be used for single file applications. And these single file apps can later on smoothly
transition to proper MVC abstraction as they grow. This is one of the fundamental mojo.js design philosophies.

## Installation

All you need to get started with mojo.js is [Node.js](https://nodejs.org) 15.0.0 (or newer). We do recommend the use of
an [nvm](https://nvm.sh) environment though.

```
$ npm install -g @mojojs/mojo
...
```

You can install mojo.js with `npm` globally, or in a project specific `node_modules` directory.

```
$ mkdir myapp
$ cd myapp
$ npm i @mojojs/mojo
...
```

Be aware that mojo.js uses [ES modules](https://nodejs.org/api/esm.html), so your `package.json` should include a
`"type": "module"`. Or you have to use the `.mjs` file extension instead of `.js`.

```json
{
  "type": "module",
  "dependencies": {
    "@mojojs/mojo": ">=0.0.1-alpha.21"
  }
}
```

## Hello World

A simple Hello World application looks like this. Save it into a file `myapp.js` and you already got a fully functional
web application. The whole framework was specifically designed with `async`/`await` in mind, so almost everything
returns a `Promise`.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

app.get('/', async ctx => {
  await ctx.render({text: 'Hello World!'});
});

app.start();
```

There is also a helper command available to generate a small example application for you.

```
$ npx mojo gen-lite-app
...
```

## Commands

Many different commands are automatically available from the command line.

```
$ node myapp.js server
[39028] Web application available at http://127.0.0.1:3000/

$ node myapp.js server -l http://*:8080
[39029] Web application available at http://127.0.0.1:8080/

$ node myapp.js get /
Hello World!

$ node myapp.js --help
...List of available commands...
```

The `app.start()` call, which is usually the last statement in your application, starts the command system.


## Reloading

During development you don't want to restart your web server after every change, so we recommend the use of
[nodemon](https://www.npmjs.com/package/nodemon).

```
$ npm i nodemon
...

$ npx nodemon myapp.js server
...
[39248] Web application available at http://127.0.0.1:3000/
```

## Routes

Routes are basically just fancy paths that can contain different kinds of placeholders and usually lead to an action, if
they match the path part of the request URL. The first argument passed to all actions (`ctx`) is a context object,
containing both the HTTP request and response.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// Route leading to an action that renders some text
app.get('/foo', async ctx => {
  await ctx.render({text: 'Hello World!'});
});

app.start();
```

Response content is almost always generated by actions with a `ctx.render()` call, but more about that later.

## GET and POST Parameters

All `GET` and `POST` parameters sent with the request are accessible via `ctx.params()`, which returns a `Promise` that
resolves with a [URLSearchParams](https://nodejs.org/api/url.html#url_class_urlsearchparams) object.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// GET /foo?user=sri
app.get('/foo', async ctx => {
  const params = await ctx.params();
  const user = params.get('user');
  await ctx.render({text: `Hello ${user}.`});
});

app.start();
```

And for a little more control there are also methods to retrieve parameters separately.

```js
// Query parameters
const params = ctx.req.query();

// "application/x-www-form-urlencoded"
const params = await ctx.req.form();

// "multipart/form-data"
const params = await ctx.req.formData();
```

## Stash and Views

The `stash` is a plain object and a property of the context object. It is used primarily to pass data to views. And
while views can be inlined for single file apps, they are usually kept as separate files in a `views` directory.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// Route leading to an action that renders a view
app.get('/foo', async ctx => {
  ctx.stash.one = 23;
  await ctx.render({inline: magicTemplate}, {two: 24});
});

app.start();

const magicTemplate = `
The magic numbers are <%= one %> and <%= two %>.
`;
```

The default mojo.js template engine is [ejs](https://www.npmjs.com/package/ejs), but any other template system can be
integrated, and will work just as well.

## HTTP

The `req` and `res` properties of the context object give you full access to all HTTP features and information.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// Access request information
app.get('/agent', async ctx => {
  const host = ctx.req.url.hostname;
  const ua = ctx.req.get('User-Agent');
  await ctx.render({text: `Request by ${ua} reached ${host}.`);
});

// Echo the request body and send custom header with response
app.get('/agent', async ctx => {
  ctx.res.set('X-Bender', 'Bite my shiny metal ass!');
  const content = await ctx.req.text();
  await ctx.render({text: content});
});

app.start();
```

Use this little cheatsheet to remember the most commonly used request and response properties that are not otherwise
mentioned in this guide.

```js
// Request method
const method = ctx.req.method;

// Full request URL
const url = ctx.req.url;

// Remote address
const address = ctx.req.remoteAddress;

// Userinfo (Basic authentication)
const userinfo = ctx.req.userinfo;

// Request ID
const requestId = ctx.req.requestId;

// Request header
const accept = ctx.req.get('Accept');

// Get cookie
const cookie = ctx.req.getCookie('foo');

// Request body as string
const content = await ctx.req.text();

// Request body as `Buffer`
const buffer = await ctx.req.buffer();

// Pipe request body to `stream.Writable` object
await ctx.req.pipe(process.stdout);
```
```js
// Set response code
ctx.res.status(200);

// Set response header
ctx.res.set('Content-Type', 'quote/futurama');

// Set cookie
ctx.res.setCookie('user', 'Bender', {path: '/', httpOnly: true});

// Send `stream.Readable` object as response body
ctx.res.send(stream);
```

For URLs we always use standard [URL](https://nodejs.org/api/url.html#url_the_whatwg_url_api) objects. And if you need a
little more control, you can also access the underlying
[http.IncomingMessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage) and
[http.ServerResponse](https://nodejs.org/api/http.html#http_class_http_serverresponse) objects via the `raw` property.

```js
// Get HTTP version
const version = ctx.req.raw.httpVersion;

// Check if response has been written already
const isFinished = ctx.res.raw..writableFinished;
```

## JSON

Of course there is first class support for JSON as well.

```js
import mojo from '@mojojs/mojo';

const app = mojo();

// Modify the received JSON object and return it
app.put('/add/quote', async ctx => {
  const data = await ctx.req.json();
  data.quote = "I don't remember ever fighting Godzilla... But that is so what I would have done!";
  await ctx.render({json: data});
});

app.start();
```

You can test all these examples right from the command line with the `get` command.

```
$ node myapp.js get -X PUT -b '{"hello":"mojo"}' /add/quote
```
